package uk.gov.justice.digital.hmpps.hmppslaunchpadauth.resource

import io.swagger.v3.oas.annotations.Hidden
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import uk.gov.justice.digital.hmpps.hmppslaunchpadauth.constant.AuthServiceConstant.Companion.INVALID_REQUEST_MSG
import uk.gov.justice.digital.hmpps.hmppslaunchpadauth.dto.View
import uk.gov.justice.digital.hmpps.hmppslaunchpadauth.exception.ApiErrorTypes
import uk.gov.justice.digital.hmpps.hmppslaunchpadauth.exception.SsoException
import uk.gov.justice.digital.hmpps.hmppslaunchpadauth.model.Scope
import uk.gov.justice.digital.hmpps.hmppslaunchpadauth.service.SsoLogInService
import java.util.*

@RestController
@RequestMapping("/v1/oauth2")
@Tag(name = "authorization")
class AuthController(private var ssoLoginService: SsoLogInService) {
  companion object {
    const val MAX_STATE_OR_NONCE_SIZE = 128
    const val SSO_SUPPORTED_RESPONSE_TYPE = "code"
    private val logger = LoggerFactory.getLogger(AuthController::class.java)
  }

  @Value("\${launchpad.auth.allowlisted-scopes}")
  private lateinit var allowListedScopes: String

  @Operation(
    summary = "Initiate user authentication request.",
    description = "Initiate user authentication to retrieve the authorization_code.",
  )
  @ApiResponses(
    value = [
      ApiResponse(
        responseCode = "302",
        description = "Redirect to url provided in redirect uri with state and nonce as query parameter.",
      ),
      ApiResponse(
        responseCode = "400",
        description = "Bad request.",
      ),
      ApiResponse(
        responseCode = "403",
        description = "Access Denied.",
      ),
    ],
  )
  @GetMapping("/authorize")
  fun authorize(
    @Parameter(required = true, description = "The id of the client making the request.")
    @RequestParam("client_id") clientId: UUID,
    @Parameter(required = true, description = "Value is always code to indicate that the authorization_code flow should be initiated.")
    @RequestParam("response_type") responseType: String,
    @Parameter(required = true, description = "One or more space-delimited scopes that the client is requesting. A client cannot request a scope that it has not been granted.")
    @RequestParam scope: String,
    @Parameter(required = true, description = "One of the registered redirect uris that the client wants us to redirect to in url-encoded format.")
    @RequestParam("redirect_uri") redirectUri: String,
    @Parameter(
      required = false,
      description = "Generated by the client making the request. Used to prevent CSRF attacks and to maintain the state between the request and the callback." +
        " Same value is returned in the callback so you can validate it. Although optional, it is recommended. Max character length is 128.",
    )
    @RequestParam(required = false) state: String?,
    @Parameter(
      required = false,
      description = "Generated by the client making the request. Same value is returned in the id_token so you can validate it. Used to prevent replay attacks." +
        " Although optional, it is recommended. Max character length is 128.",
    )
    @RequestParam(required = false) nonce: String?,
  ): View {
    validateResponseType(responseType, redirectUri, state)
    validateSize(state, "state", redirectUri, state)
    validateSize(nonce, "nonce", redirectUri, state)
    val scopes = Scope.removeAllowListScopesNotRequired(scope, allowListedScopes.split(","))
    val url = ssoLoginService.initiateSsoLogin(clientId, responseType, scopes, redirectUri, state, nonce)
    logger.info("Sign in request sent to azure for client $clientId")
    return View(url)
  }

  @Hidden
  @PostMapping("/callback", consumes = ["application/x-www-form-urlencoded"])
  fun getAuthCode(
    @RequestParam("id_token", required = false) token: String?,
    @RequestParam state: UUID,
  ): Any {
    return ssoLoginService.updateSsoRequest(token, state)
  }

  @Hidden
  @PostMapping("/authorize-client", consumes = ["application/x-www-form-urlencoded"])
  fun authorizeClient(
    @RequestParam state: UUID,
    @RequestParam("user_approval") userApproval: String,
  ): Any {
    if (userApproval == "approved") {
      return ssoLoginService.updateSsoRequest(null, state)
    } else {
      // user did not approved the client so delete sso request
      return ssoLoginService.cancelAccess(state)
    }
  }

  private fun validateSize(value: String?, paramName: String, redirectUri: String, clientState: String?) {
    // validate query param length, optional param can be null or if not null should not exceed 128 max size
    if (value != null) {
      if (value.length > MAX_STATE_OR_NONCE_SIZE) {
        val message = "$paramName size exceeds 128 char size limit"
        throw SsoException(
          message,
          HttpStatus.FOUND,
          ApiErrorTypes.INVALID_REQUEST.toString(),
          INVALID_REQUEST_MSG,
          redirectUri,
          clientState,
        )
      }
    }
  }

  private fun validateResponseType(responseType: String, redirectUri: String, clientState: String?) {
    if (responseType != SSO_SUPPORTED_RESPONSE_TYPE) {
      val message = "Response type: $responseType is not supported"
      throw SsoException(
        message,
        HttpStatus.FOUND,
        ApiErrorTypes.INVALID_REQUEST.toString(),
        INVALID_REQUEST_MSG,
        redirectUri,
        clientState,
      )
    }
  }
}
